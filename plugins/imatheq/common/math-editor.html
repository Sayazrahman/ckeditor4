<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Math Formula Editor</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- MathLive -->
<script src="https://cdn.jsdelivr.net/npm/mathlive/dist/mathlive.min.js"></script>

<!-- MathJax -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [["\\(", "\\)"], ["$", "$"]],
    displayMath: [["\\[", "\\]"], ["$$", "$$"]],
    packages: ["base", "ams", "noerrors", "noundefined", "autoload"],
  },
  svg: { fontCache: "global" },
  startup: {
    ready: () => {
      console.log("MathJax ready");
      MathJax.startup.defaultReady();
    }
  }
};
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-svg-full.js" async></script>

<style>
  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  body {
    font-family: Arial, sans-serif;
    background: white;
    padding: 20px;
    height: 100vh;
    display: flex;
    flex-direction: column;
  }

  .header {
    background: #6b4c7a;
    color: white;
    padding: 15px 20px;
    border-radius: 8px 8px 0 0;
    margin: -20px -20px 20px -20px;
  }

  .header h2 {
    margin: 0;
    font-size: 18px;
  }

  .content {
    flex: 1;
    overflow: auto;
  }

  #math-toolbar {
    background: #f0f0f0;
    border: 1px solid #ccc;
    padding: 8px;
    margin-bottom: 15px;
    border-radius: 4px;
    display: flex;
    flex-wrap: wrap;
    gap: 3px;
  }

  .math-btn {
    width: 36px;
    height: 32px;
    border: 1px solid #999;
    background: #fff;
    cursor: pointer;
    font-size: 13px;
    border-radius: 3px;
    transition: background 0.2s;
  }

  .math-btn:hover {
    background: #e9ecef;
  }

  #mathlive-editor {
    width: 100%;
    min-height: 150px;
    font-size: 20px;
    border: 2px solid #ddd;
    border-radius: 6px;
    padding: 15px;
    background: white;
    margin-bottom: 15px;
  }

  .latex-preview-container {
    padding: 10px;
    background: #f8f9fa;
    border: 1px solid #e9ecef;
    border-radius: 4px;
    margin-bottom: 15px;
  }

  .latex-preview-container b {
    font-size: 13px;
    color: #555;
  }

  #latex-preview {
    font-size: 12px;
    margin-top: 5px;
    color: #222;
    word-wrap: break-word;
  }

  .export-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 15px;
  }

  .export-btn, #math-clear {
    padding: 8px 12px;
    border: 1px solid;
    background: white;
    border-radius: 4px;
    font-size: 12px;
    cursor: pointer;
    transition: background 0.2s;
  }

  .export-btn:hover, #math-clear:hover {
    background: #f8f9fa;
  }

  .export-btn[data-type="mathml"] {
    border-color: #007bff;
    color: #007bff;
  }

  .export-btn[data-type="svg"] {
    border-color: #28a745;
    color: #28a745;
  }

  .export-btn[data-type="png"] {
    border-color: #ffc107;
    color: #856404;
  }

  #math-clear {
    border-color: #dc3545;
    color: #dc3545;
  }

  .footer {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    padding-top: 15px;
    border-top: 1px solid #e9ecef;
  }

  .btn {
    padding: 10px 24px;
    border: none;
    border-radius: 4px;
    font-size: 14px;
    cursor: pointer;
    transition: opacity 0.2s;
  }

  .btn:hover {
    opacity: 0.9;
  }

  .btn-cancel {
    background: #6c757d;
    color: white;
  }

  .btn-save {
    background: #007bff;
    color: white;
  }
</style>
</head>

<body>

<div class="header">
  <h2>Insert Mathematical Formula</h2>
</div>

<div class="content">
  <!-- Toolbar -->
  <div id="math-toolbar"></div>

  <!-- MathLive Input Field -->
  <math-field
    id="mathlive-editor"
    virtual-keyboard-mode="manual"
    smart-fence="true"
    keypress-sound="none"
  ></math-field>

</div>

<div class="footer">
  <button class="btn btn-cancel" onclick="cancelDialog()">Cancel</button>
  <button class="btn btn-save" onclick="saveFormula()">Save</button>
</div>

<script>
/* ============================
   LATEX → MATHML / PNG
   ============================ */

function latexToMathML(latex) {
  try {
    if (window.MathJax && MathJax.tex2mml) {
      return MathJax.tex2mml(latex);
    }
  } catch (e) {
    console.warn("MathML conversion failed", e);
  }
  return `<math><mtext>${latex}</mtext></math>`;
}

function createFallbackImage(latex, canvas, ctx) {
  const text = latex.length > 20 ? latex.substring(0, 20) + "..." : latex;

  ctx.font = "16px serif";
  const w = ctx.measureText(text).width;

  canvas.width = w + 20;
  canvas.height = 40;

  ctx.fillStyle = "#f8f9fa";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.strokeStyle = "#ccc";
  ctx.strokeRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = "#333";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(text, canvas.width / 2, canvas.height / 2);

  return canvas.toDataURL("image/png");
}

async function latexToPNG(latex) {
  return new Promise(async (resolve, reject) => {
    try {
      // Wait for MathJax to be ready
      if (!window.MathJax || !MathJax.tex2svg) {
        console.log("MathJax not ready yet, waiting...");
        // Wait up to 3 seconds for MathJax
        let attempts = 0;
        while ((!window.MathJax || !MathJax.tex2svg) && attempts < 30) {
          await new Promise(r => setTimeout(r, 100));
          attempts++;
        }
        
        if (!window.MathJax || !MathJax.tex2svg) {
          console.log("MathJax failed to load, using text fallback");
          return resolve(createFallbackPNG(latex));
        }
      }

      console.log("Using MathJax to render formula");
      
      // Convert LaTeX to SVG using MathJax
      const svg = MathJax.tex2svg(latex);
      const svgElement = svg.querySelector('svg');
      
      if (!svgElement) {
        console.error("No SVG element generated");
        return resolve(createFallbackPNG(latex));
      }
      
      // Get SVG dimensions
      const bbox = svgElement.getBBox();
      const width = Math.max(bbox.width, 100);
      const height = Math.max(bbox.height, 40);
      
      // Create canvas with higher scale for better quality
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      const scale = 4; // Increased scale for better quality
      
      canvas.width = (width + 40) * scale;
      canvas.height = (height + 40) * scale;
      
      // White background
      ctx.fillStyle = "white";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Convert SVG to image
      const svgString = new XMLSerializer().serializeToString(svgElement);
      const img = new Image();
      const svgBlob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
      const url = URL.createObjectURL(svgBlob);
      
      img.onload = () => {
        ctx.scale(scale, scale);
        ctx.drawImage(img, 20, 20, width, height);
        
        const dataUrl = canvas.toDataURL("image/png");
        console.log("MathJax PNG generated, length:", dataUrl.length);
        console.log("Canvas size:", canvas.width, "x", canvas.height);
        URL.revokeObjectURL(url);
        resolve(dataUrl);
      };
      
      img.onerror = (err) => {
        console.error("Image load failed:", err);
        URL.revokeObjectURL(url);
        resolve(createFallbackPNG(latex));
      };
      
      img.src = url;
      
    } catch (error) {
      console.error("PNG generation failed:", error);
      resolve(createFallbackPNG(latex));
    }
  });
}

// Fallback PNG with text
function createFallbackPNG(latex) {
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  
  const fontSize = 20;
  ctx.font = `${fontSize}px Arial`;
  const text = latex.length > 30 ? latex.substring(0, 30) + "..." : latex;
  const metrics = ctx.measureText(text);
  const textWidth = metrics.width;
  
  canvas.width = textWidth + 40;
  canvas.height = fontSize + 30;
  
  ctx.font = `${fontSize}px Arial`;
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  ctx.strokeStyle = "#ddd";
  ctx.lineWidth = 2;
  ctx.strokeRect(0, 0, canvas.width, canvas.height);
  
  ctx.fillStyle = "#000";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(text, canvas.width / 2, canvas.height / 2);
  
  console.log("Fallback PNG generated");
  return canvas.toDataURL("image/png");
}

/* ============================
   INITIALIZE
   ============================ */

function initializeToolbar() {
  const buttons = [
    ["\\frac{#@}{#?}", "a/b"],
    ["^{#?}", "x²"],
    ["_{#?}", "x₁"],
    ["\\sqrt{#?}", "√"],
    ["\\sqrt[#@]{#?}", "ⁿ√"],
    ["\\int_{#@}^{#?}", "∫"],
    ["\\sum_{#@}^{#?}", "Σ"],
    ["\\prod_{#@}^{#?}", "∏"],
    ["\\lim_{#?}", "lim"],
    ["\\sin", "sin"],
    ["\\cos", "cos"],
    ["\\tan", "tan"],
    ["\\log_{#?}", "log"],
    ["\\ln", "ln"],
    ["\\infty", "∞"],
    ["+", "+"],
    ["-", "−"],
    ["\\times", "×"],
    ["\\div", "÷"],
    ["=", "="],
    ["\\neq", "≠"],
    ["\\geq", "≥"],
    ["\\leq", "≤"],
    ["\\pi", "π"],
    ["\\theta", "θ"],
    ["\\alpha", "α"],
    ["\\beta", "β"],
    ["\\gamma", "γ"],
    ["\\left|#?\\right|", "|x|"],
    ["\\left(#?\\right)", "( )"],
    ["\\left[#?\\right]", "[ ]"],
    ["\\rightarrow", "→"],
    ["\\Rightarrow", "⇒"],
  ];

  const toolbar = document.getElementById('math-toolbar');
  toolbar.innerHTML = buttons
    .map(([cmd, label]) => `
      <button class="math-btn" data-command="${cmd}" type="button">
        ${label}
      </button>
    `)
    .join('');
}

function setupEvents() {
  const field = document.getElementById('mathlive-editor');
  const preview = document.getElementById('latex-preview');

  // Live preview
  function updatePreview() {
    preview.textContent = field.getValue('latex') || '(empty)';
  }
  field.addEventListener('input', updatePreview);

  // Toolbar buttons
  document.querySelectorAll('.math-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const cmd = btn.getAttribute('data-command');
      if (!cmd) return;
      field.focus();
      field.insert(cmd);
      setTimeout(updatePreview, 20);
    });
  });

  // Export buttons
  document.querySelectorAll('.export-btn').forEach(btn => {
    btn.addEventListener('click', async () => {
      const type = btn.getAttribute('data-type');
      const latex = field.getValue('latex');
      if (!latex) return;

      if (type === 'mathml') {
        const mathml = latexToMathML(latex);
        copyToClipboard(mathml, 'MathML');
      }

      if (type === 'svg') {
        try {
          const svg = MathJax.tex2svg(latex);
          const svgString = MathJax.startup.adaptor.outerHTML(svg);
          copyToClipboard(svgString, 'SVG XML');
        } catch (e) {
          alert('SVG export failed: ' + e.message);
        }
      }

      if (type === 'png') {
        const png = await latexToPNG(latex);
        downloadImage(png, 'formula.png');
      }
    });
  });

  // Clear button
  document.getElementById('math-clear').addEventListener('click', () => {
    field.setValue('');
    updatePreview();
  });
}

// Set initial latex (called from parent)
window.setInitialLatex = function(latex) {
  const field = document.getElementById('mathlive-editor');
  const preview = document.getElementById('latex-preview');
  field.setValue(latex);
  preview.textContent = latex;
};

// Save formula
async function saveFormula() {
  const field = document.getElementById('mathlive-editor');
  const latex = field.getValue('latex');
  
  if (!latex.trim()) {
    alert('Please enter a formula first!');
    return;
  }

  try {
    console.log('Converting LaTeX to MathML...');
    
    // Convert LaTeX to MathML
    const mathML = latexToMathML(latex);
    const encodedMathML = encodeURIComponent(mathML);
    
    // Create SVG with embedded MathML - NO fixed viewBox, let it size naturally
    const svgData = `<svg xmlns="http://www.w3.org/2000/svg">
      <foreignObject x="0" y="0" width="100%" height="100%">
        <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">${mathML}</math>
      </foreignObject>
    </svg>`;
    
    const imgSrc = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svgData)}`;
    
    console.log('SVG with MathML created');
    
    // Send to parent window
    if (window.parent && window.parent !== window) {
      if (window.parent.receiveFormulaFromMathEditor) {
        console.log('Calling parent function...');
        window.parent.receiveFormulaFromMathEditor(latex, imgSrc, encodedMathML);
      } else {
        console.error('Parent function not found!');
        alert('Error: Parent window function not available');
      }
    } else {
      console.error('No parent window found!');
      alert('Error: Not running in iframe');
    }
  } catch (error) {
    console.error('Error saving formula:', error);
    alert('Error generating formula: ' + error.message);
  }
}

// Cancel dialog
function cancelDialog() {
  if (window.parent && window.parent.closeMathDialog) {
    window.parent.closeMathDialog();
  }
}

// Utility functions
function copyToClipboard(text, label) {
  navigator.clipboard.writeText(text)
    .then(() => alert(label + ' copied to clipboard!'))
    .catch(() => {
      prompt('Copy ' + label + ':', text);
    });
}

function downloadImage(dataUrl, filename) {
  const a = document.createElement('a');
  a.href = dataUrl;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
}

// Keyboard shortcuts
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape') {
    cancelDialog();
  } else if (e.key === 'Enter' && e.ctrlKey) {
    saveFormula();
  }
});

// Initialize on load
window.addEventListener('load', () => {
  initializeToolbar();
  setupEvents();
});
</script>

</body>
</html>